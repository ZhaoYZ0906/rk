### 软件工程概述

软件生存周期

1. 可行性分析与项目开发计划
2. 需求分析
3. 概要设计
4. 详细设计
5. 编码
6. 测试
7. 维护



软件过程

CMM：过程能力成熟度模型

初始级：杂乱无章、混乱。完全依靠个人努力

可重复级：建立基本的项目管理过程和实践

已定义级：软件标准化，保留文档、针对组织的标准化

已管理级：详细的质量标准

优化级别：不断优化改进



CMMI：过程能力成熟度集成模型

初始级：杂乱无章、混乱。完全依靠个人努力

可管理级：纪律化过程

已定义级：可预测过程

定量管理级：不断改进过程

优化管理级：



CL0：为执行或未得到

CL1: 可标识输入转换成可标识输出

CL2: 已管理的过程制度化

CL3: 已定义的过程制度化

CL4: 可定量管理的过程制度化

CL5: 量化手段改变和优化过程域



### 软件开发方法

结构化方法（面向过程）：适用于需求明确的项目，需求具有渐进、明晰性

1. 用户至上
2. 自顶向下，逐步分解
3. 严格区分工作阶段，每个阶段都有特定的产物
4. 强调系统开发方的整体性、全局性
5. 开发过程工程化，文档标准化

原型法：适用于需求不明确。先做设计图，和用户讨论，帮助用户明确需求

面向对象方法

1. 更好的复用性
2. 关键在于建立一个全面、合理、统一的模型
3. 分析、设计、实现三个阶段，界限不明显

面向服务方法

1. 抽象级别：操作、服务、业务流程



### 软件开发模型

瀑布模型

考的频繁

结构化思想，以文档作为驱动，需求明确且一般不会改变，自上而下

1. 软件计划
2. 需求分析
3. 软件设计
4. 程序编码
5. 软件测试
6. 运行维护

V模型：验证确认活动适用于早期的软件工程工作中，测试贯穿始终

1. 软件计划         考虑系统测试、验收测试
2. 概要设计         考虑集成测试
3. 详细设计         考虑单元测试
4. 程序编码

原型模型：迭代的过程模型，通过一轮又一轮的开发使软件逐渐完整，适用于需求缺乏准确认识的情况，强调明确需求

1. 与客户交流
2. 快速计划、快速设计方式原型。细分模型包含 抛弃型原型：下一轮不再用；演化型原型：下一轮在此基础上继续改造；探索型原型：逐步探索需求；实验性原型，通过算法验证数据。
3. 构建原型
4. 部署交付和反馈。之后再执行1

螺旋模型：瀑布模型+演化模型结合，加入风险分析。适用于庞大、复杂、高风险的系统开发

1. 制定计划
2. 风险分析，只要有风险就是螺旋模型
3. 实施计划
4. 客户评估，依次重复



增量模型：强调核心产品当做第一个增量开发，每个增量开发完成后会有一个交付版本，下一增量开发再此交付版本上开发。将需求分段为一系列增量，每一增量可以分别开发。核心增量贯穿整个过程，保证核心最稳定，最优。缺点：增量的划分，核心产品的确定



喷泉模型：面向对象开发模型，以用户需求为动力，以对象作为驱动模型，各个环节无明显间隙，各个环节可以相互交叉比如实现的时候可以设计，测试的时候可以分析

自下而上 分析-设计--实现-测试-维护-演化



统一过程UP/RUP，用例驱动，以架构为中心，迭代和增量

考的少,考的细

初始：确定项目范围、边界，识别系统关键用例，展示候选价格，评估用时，评估项目风险（但不强调风险，只有螺旋模型强调）

细化：建立软件架构基础，分析问题领域，淘汰最高风险元素

构建：构件组装与测试，开发剩余构建，生成可使用程序。构件：某个业务的对象集合（比如订单），可复用，也可理解为范围扩大的类

交付：制作发部版本，进行生产测试，文档定稿，确认新系统，培训

可能和测试驱动开发一个原理



敏捷开发模型：适合小项目小团队，小步快跑，高效率，尽快提交可交付版本之后慢慢迭代，减少文档，客户直接参与，适应性计划调整，自动化测试，结对编程（俩人编一个代码，综合两个人思想并防止人员流失），测试驱动开发，持续集成，重构



极限编程思想（敏捷开发的一种）

四大价值观：沟通、简单、反馈、勇气

五大原则：快速反馈、做简单的假设、逐步修改、提倡更改、优质工作

12最佳时间

1. 计划游戏，快速指定计划并不断调整完善
2. 小型发部：系统叫可能早的交付
3. 隐喻：找到合适的比喻传达信息
4. 简单设计：只处理当前需求使设计保持简单
5. 测试先行：先写测试用例
6. 重构：重新审视需求和设计
7. 结对编程
8. 集体代码所有制
9. 持续集成，按日甚至小时提供可运行版本
10. 每周工作40小时
11. 现场顾客，客户全程配合开发，随时沟通问题
12. 编码标准



其他敏捷开发

并列争球法：多个自组织 自治的小组按需求并行快速实现产品，30天一个冲刺

水晶法：以人为本，强调开发人员的素质，不同的人用不同的策略

功能驱动开发：首席程序员（简单理解为会代码的项目经理，负责安排工作）和类程序员（写代码的）

开源代码

自适应开发：猜测、合作、学习



### 需求分析

以下都是基于结构化模型

需求分析：需要解决的问题有哪些

1. 问题识别
2. 分析与综合
3. 编写需求分析文档（需求规格说明书 SRS）
4. 需求分析与评审

结构化需求分析结果：数据流图、数据字典、一组小说明（加工逻辑说明）、补充材料



需求分类

​	分类：一般考这里

1. 业务需求（整体需求）
2. 用户需求（用户视角）
3. 系统需求（计算机化，针对代码的需求。分为功能需求（比如打卡）、非功能需求（一般针对性能、容量等）、设计约束（对于法律法规要求））

QFD分类：

1. 基本需求（明示，常规需求，必须完成）
2. 期望需求（隐含，必须完成）
3. 兴奋需求（多余）



需求分析工具

1. 数据流图
2. 数据字典
3. 判定表
4. 判定树



数据流图：数据在系统中如何传送或变化，一级如何对数据流进行变化的功能或子功能，用于对功能建模

数据流：一个箭头 ->

加工：原型或者圆角矩形，描述流入数据与流出数据的变化

数据存储：平行线，封了一侧的矩形。流向表示写入，流出表示读取

外部实体：存在与软件系统外的人员或组织，一般用矩形表示



数据流图的自顶向下逐步分解，所以可以分为好几个颗粒度不同的图



数据字典

数据字典有以下4类条目：数据流、数据项、数据存储、基本加工，源点和终点为外部实体，不在系统之内，所以不在字典中说明

= 被定义

+为与，x=a+b，x由a和b组成

x=[a,b] 或 x=[a|b] 为x为a或b

x={a} 为 x由0个或多个a组成

x=（a）为 a可以在x中出现也可以不出现



结构化语言：自然语言和形式化语言之间的半形式化语言，外层一般有顺序结构、选择结构、重复结构。内层一般使用祈使语句的自然语言短语

判定表：将条件取值对应的动作以表的形式记录下来

判定树：判定表转换为数





### 系统设计

结构化开发设计

1. 概要设计：划分子系统、模块，进行分配任务。
2. 详细设计：针对模块内部进行设计
3. 体系结构设计：架构设计
4. 数据设计：数据库设计
5. 接口设计：人机界面设计
6. 过程设计：系统结构部件转换为软件的过程



模块设计（必考，考的多）

原则：

1. 保持模块大小适中
2. 多扇入少扇出，要适中不要太多。当前函数掉其他函数为扇出，反之扇入
3. 尽可能减少调用的深度
4. 单入口，单出口
5. 模块的作用域应该在模块控制域之内，作用域：当前模块的范围；控制域：主程序+所有调用模块组合的域
6. 功能应该可预测
7. 高内聚
   1. 功能内聚：功能单一
   2. 顺序内聚：处理元素必须顺序执行
   3. 通信内聚：所有处理元素集中在一个数据结构的区域上
   4. 过程内聚：处理元素相关必须按特定的次序执行
   5. 瞬时（时间）内聚：所包含的任务必须在同一时间间隔内执行
   6. 逻辑内聚：完成逻辑上相关的一组任务
   7. 偶然内聚：完成一组没有关系或松散关系的任务
8. 低耦合
   1. 非直接耦合：两个模块没有直接关系，联系通过主模块的控制和调用实现
   2. 数据耦合：借助参数表来传递简单数据（传递变量比如 a=1）
   3. 标记耦合：借助参数表来传递记录信息（传递对象比如 user=xx）
   4. 控制耦合：传递的信息包含控制模块内部逻辑的信息
   5. 外部耦合：一组模块访问同一个全局简单变量。全局变量 int a
   6. 公共耦合：多个模块访问同一个公共数据环境。全局变量 hashtable tab1
   7. 内容耦合：一个模块直接访问另外一个模块的内部数据；两个模块有代码重叠；不通过正常入口转到另一个模块；一个模块多个入口



人机界面设计（接口设计）

考的不高

黄金三原则

1. 置于用户控制之下：不出现意外的情况，比如程序卡死就不在用户控制之下
2. 减少用户记忆负担
3. 保持界面一致性





架构设计

一般考1分

核心问题：能否达到架构级的软件复用

架构风格：反应领域中众多结构和语义的特性，定义了系统的术语表和知道构建系统的规则



数据流风格：

1. 批处理：数据必须完整，以整体方式传递
2. 管道-过滤器：一步一步处理，前面的输出作为后面的输入

调用/返回风格：

1. 主程序/子程序：单线程
2. 面向对象：显示调用（写在代码里面调用哪个）
3. 层次结构（cs、bs、mvc）

独立构建风格：

1. 进程通信
2. 事件驱动：隐式调用（触发实事件自动调用）

虚拟机风格：

1. 解释器
2. 基于规则的系统：用于人工智能领域

仓库风格：操作不明确（无法记录操作，别人执行一个sql我无法知道具体操作了什么），测试复杂

1. 数据库系统
2. 超文本系统
3. 黑板系统：包含知识源、黑板、控制三部分



### 软件测试

目的：找到未发现的错误

1. 尽早、不断的进行测试
2. 避免测试自己设计的程序
3. 纪要有效、合理的数据，也要无效、不合理的数
4. 修改后应进行回归测试
5. 尚未发发现的错误数量与已发现的错误数量成正比，发现的越多，未发现的越多



分类

 静态测试（纯人工）：

1. 桌前检查
2. 代码审查
3. 代码走查

动态测试（机器运行）：

1. 黑盒
2. 白盒
3. 灰盒：暂时不考



黑盒测试（好久不考）

等价类划分

1. 确定无效（无效数据）与有效类（有效数据）
2. 设计尽可能多的覆盖有效类（所有有效类）
3. 设计一个无效类

边界值分析

1. 选取的测试数据应刚好等于、稍小于、稍大于边界值



白盒测试（必考）

逻辑覆盖：

1. 语句覆盖：每个语句（不包含判定）至少执行一次，一般人为时弱的逻辑覆盖
2. 判定覆盖（分支覆盖）：每个判定结果的真假值都要判定一次。判定可能是多个条件组合或单个条件
3. 条件覆盖：每个逻辑条件的可能值至少满足一次。
4. 判定/条件覆盖：每个判定中各种可能值的组合至少出现一次
5. 路径覆盖：执行所有的可能路径
6. 以下了解
7. 条件组合覆盖：各个判定中可能值的组合至少出现一次。
8. 基本路径测试：每一条独立路径都执行过
9. 循环覆盖：循环中每个条件都得到验证



判定覆盖、条件覆盖、判定/条件覆盖区别

1. 有条件a&b
2. 判定覆盖：（a=t，b=t）+（a=t，b=f）或（a=f，b=t）或（a=f，b=f） 最终结果真假都出现
3. 条件覆盖：（a=t，b=t）+（a=f，b=f）或（a=t，b=f）+（a=f，b=t） 每个变量的可能值都出现
4. 判定/条件覆盖：（a=t，b=t）+（a=t，b=f）+（a=f，b=t）+（a=f，b=f）
