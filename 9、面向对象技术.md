### 基本概念

万物皆对象

静态特征-属性，动态特征-行为（方法）。内部细节在外部不可见

对象包含：id（对象名，实例化名称） 属性 行为

消息：方法调用，对象的消息是对象的某个方法被调用。默认是异步

状态：一组属性集合表示状态

接口：一种调用的方式（二维码、条形码、窗体、显示器也算接口）

控制类：用来控制活动流



继承：子类继承父类

泛化：子类抽象出父类的过程

覆盖/重置/重写：子列重写父类方法

重载：一个类中存在多个同名但参数不一致的方法



多态与动态绑定：父类对象在被调用的时候，动态检查是哪个子类，执行子类具体的方法。因为父类可以接收子类  f f1= new z() ;  f.xx()  执行 z的xx方法 

运行时检查为动态绑定，编译时检查为静态绑定

过载多态：同一名称对象在不同上下文中产生不同效果

上下文1： f f1= new z() ;  f.xx()  

上下文2： f f1= new x() ;  f.xx()  



### 面向对象分析

考的不多

喷泉模型，各个环节之间无间隙

1. 分析
2. 设计
3. 代码实现
4. 测试



学会从文字中抽象出对象，找清楚属性和方法



### 面向对象设计

主要靠设计原则，上午考的不多

面向对象7大原则

1. 单一职责原则
2. 开放-封闭原则：扩展开放，修改封闭
3. 里氏替换原则：子类可以替换父类
4. 依赖倒置：依赖于抽象，而不是具体实现
5. 接口隔离原则：使用多个小接口比用一个大接口好一些。所有的方法集成在一个大接口中，大接口的职责不再单一
6. 组合重用原则，尽量使用组合，而不是继承，可降低耦合性
7. 迪米特原则（最少知识原则）：一个对象尽量少的了解本身之外的对象

其他原则（主要针对包、数据集） 考得不多

1. 重用发部等价原则：重用的粒度就是发部的粒度
2. 共同封闭原则：一个包中的所有类对同一性质的变化应该是共同封闭的
3. 共同重用原则：一个包中的所有类对同一性质的重用应该是共同封闭的
4. 无环依赖原则：无循环依赖
5. 稳定依赖：朝稳定的方向进行依赖
6. 稳定抽象：包的抽象程度应该和稳定程度一致



### UML

面向对象方法：booch、oose、omt 使用uml2.0

面向数据结构：jsckson

面向过程：结构化方法



uml分类：结构图、行为图

结构图（静态图）

1. 类图：一组对象、接口、协作他们之间的关系
2. 对象图：一组对象他们之间的关系，静态快照
3. 包图：类与包之间的依赖关系
4. 组合结构图：分解类、组成或用例的内部结构
5. 构件图：构件之间的组织和依赖
6. 部署图：软硬件之间的映射
7. 制品图

行为图（动态图）

1. 用例图：系统与外部参与者交互 ：用例、参与者一级他们之间的关系
2. 顺序图：强调按时间顺序  
3. 通信图：协作图，强调手法消息的对象之间的组织结构
4. 顶视图
5. 状态图：展现一个状态机，有状态、事件、转换构成
6. 活动图：类似于程序流程图，并行行为，一个活动到另一个活动
7. 交互概览图



关系

类图：

1. 关联关系：直接连接，可标准 1：1/1：n关系，或角色，可以有不同角色的多个关联
2. 依赖：虚线实箭头（ ->），一个事务变化影响另一个事务
3. 泛化：实线空心箭头，箭头指向父类
4. 实现：虚线空心箭头，箭头指向接口
5. 聚合：实线空心菱形箭头，整体与部分生命周期不同。大雁和雁群是聚合，雁群散了大雁继续存在
6. 组合：实线实心菱形箭头，整体与部分生命周期相同。翅膀和大雁，大雁死了，翅膀没有意义

用例图：

1. 包含：标注为 《include》   必选     左边为基础用例，右边为公共用例 ，必须执行基础用例再执行公共用例
2. 扩展：《extend》指向被扩展对象（基本用例） 可选  满足某个条件再执行
3. 泛化：必选 父用例本身无意义，必须通过子用例执行   体现为 is a...





类图与对象图

类图为静态的关系结构，对象图为动态，某一时刻的快照

图中有1 : 1   1 : n 之类的的关系   1 可以为0（可以没有  ）  0...*  有0到多个对象     0...1 有0到1个对象



用例图

一组用例，参与者（关键时）及他们之间的关系，所有用例会被一个矩形框起来

小人-参与者，椭圆-用例，箭头参照类图中的箭头

用例建模流程 

1. 识别参与者（必须）
2. 合并需求获得用例（必须）
3. 细化用例描述（必须）
4. 调整用例模型（可选）



通信图

强调收发消息对的对象或参与者的组织结构。通信图强调组织结构，顺序图强调时序



顺序图（序列图）

体现对象与对象之间的交互，强调消息的时间次序

：类名 表示 对象   ， 虚竖线为生命线， 实线箭头 调用消息  虚线箭头 返回消息 ， 叉号 生命结束



活动图

强调控制流和数据流

实心圆为开始、结束， 圆角矩形为活动，粗实线为合并分叉/合并汇合（表示并发），菱形表示分支 菱形的条件叫监护条件  ，可以有泳道  一个角色一条泳道



状态图

优点类似于活动动图，是一个状态机，强调事件导致的对象行为，有助于反应式系统建模

实心圆为开始、结束， 圆角矩形为状态，活动在连接线上写



构建图

描绘接口、端口以及内嵌构建连接构成的内部结构。构件图用于表示系统静态设计实现视图。构件图是类图的变体

构件：矩形+两个小矩形 或 矩形里右上角画了个构件图表   需接口（锁）：一半圆圈    供结构（钥匙）：圆圈





部署图

运行时处理节点及在其中生存的构件配置，架构的静态部署图，包含物理节点（比如服务器），强调物理分布图

节点：大大的矩形，里面可以包含构件等系信息





### 设计模式

上午核心4分

创建型 5种 

1. abstract factory（抽象工厂）：生产成系列对象，一个接口创建一系列相关或相互依赖的对象，而无需指定具体的类
2. builder（构建器）：复杂对象构造，复杂类的表示与构造相分离
3. factory method（工厂方法）：动态生产对象，创建一个对象接口，由子类决定实例化哪一个类
4. prototype（原型模式）：克隆对象，用原型士力指定创建对象，通过拷贝创建新的对象，因为拷贝所以节约一定资源
5. singleton（单例）：单实例，保持只有一个实例



结构性 7种

1. adapter（适配器）：转换接口，一个接口转换为另外一个接口，使不相容的接口协同工作
2. bridge（桥接）：集成树拆分，抽象部分和实现部分分离开，可以独立的变化。理解 主程序（浏览器）的部分功能（皮肤）依赖于一个接口（皮肤接口），这个接口的子类（皮肤子类实现对象）随意变化，主程序随意变换互不影响
3. composite（组合）：树型目录结构，表示整体-部分的层次结构，单个对象与整体对象的一致性。将一个对象插入另外一个对象中
4. decorator（装饰器）：附加职责，动态的为对象添加一些额外的职责
5. facade（外观）：对外统一接口，定义一个高层接口，为子系统中的一组接口提供一个统一的外观
6. flyweight（享元）：文章共享文字对象，支持大量细粒度对象共享的有效方法。活字印刷术里面的活字
7. proxy（代理）：快捷方式，为其他对象提供一种代理控制这个对象的访问



行为型 11种

中介者模式（mediator）：各个对象不需要显式的互相调用，只需要于中介对象调用即可，从而达到低耦合

备忘录模式(mementa)：不破坏封装情况下，捕获一个对象的内部状态，并在对象之外保存这个状态，以后可以进行恢复

策略模式(strategy)：定义一系列算法，使之可以互相替换

模板方法(template method)：定义一个操作中的算法骨架，在子类中实现、补全算法细节

状态模式(state)：一个对象在内部状态发生变化时改变其行为。于策略模式区分先找关键字 state，两种模式比较像。

访问者模式(vusitor)： 需要对一个对象结构中的对象进行很多不同且不想管的操作。 访问数据放在一侧，访问逻辑放在一侧，访问逻辑依次访问数据。例如超市结账，分为人工结账、自动结账两种访问逻辑，购物车里面有多种货物作为访问数据，两种逻辑依次访问购物车中的货物

责任链模式(chain of responsibillity)：在不明确指定接收者的情况下向多个对象中的一个提交请求。参照请假，组长不能批，组长递交给科长，科长不能批，科长递交给处长，层层审批

命令模式(command)：在不同时刻指定、排列和执行不同请求

解释器模式(interpreter)：

迭代器模式(iterator)

观察者(observer)：一个对象发生变化其余对象做出相应的操作















