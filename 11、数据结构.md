### 11.1 线性结构

线性结构为逻辑结构

顺序表：可以看作一个数组

读操作：O（1） 

查询操作：依次查找，最少查1次 最多n次 平均  （n+1）/2

插入：O（n）插入一个，后面所有的元素后移  （n+1）/2

删除：O（n） 删除一个，后面所有元素前移  平均：（n-1）/2     最少0 最多n-1

内存连续分配，静态分配，使用之前申请



链表

内存不连续，前一个元素存储下一个元素的地址

首节点：第一个有效数据的节点

尾节点：最后一个有效数据的节点

头节点，首节点前的节点，放链表首地址   头节点的元素位置可放链表长度

头指针：指向头节点的指针变量

尾指针：指向尾节点的指针变量



头指针-头节点-首节点-尾节点-尾指针

1. n个节点离散分布，批次通过指针联系
2. 除头节点和尾节点外，每个节点都有一个唯一的前驱、后继节点
3. 头节点不存放有效数据，只存放链表首地址
4. 加头节点为了方便操作，比如在头部进行删除、插入



链表类型

1. 单链表
2. 循环链表
3. 双向链表

删除、插入时间复杂度 O（1）不需要移动元素，只需要修改指针即可    读操作O（n）



空间性能：

​	空间性能 顺序 事先确定；链式 动态改变     

​	存储密度 顺序=1 更优  链式<1





队列与栈

队列：先进先出，一般用循环单列表表示，入队、出队不需要遍历（由头指针和尾指针完成），入队和出队顺序一致

循环队列

队空：头指针=尾指针

队满：（尾指针+1）%总长度=头指针

队列长度：（头-尾+总长度）%总长度



栈：先近后出





串：可以是数组也可以是链表    代表：字符串

空串！=空格串

存在字符串  abcdef

字串： abc  连续得一部分

子序列： acf  可以非连续得一部分  空串也能算作 字串、子序列  

长度为n的字符串，子序列的个数为  2的n次方

例如 abc  可以转换为二进制 0为未出现 1为出现 则

空串为 000

a为 100

ab为110  以此类推共由 2的3次方个组合   



互异非平凡子串（非空且不等于本身） （n+2）（n-1）/2   找个字符串数数更快

字符串比较ascii码  串相等 长度、字符都相等



模式匹配

朴素算法：主串字符依次与子串匹配，i=j则 i+1，j+1  否则i+1   i为主。最简单的匹配算法

KMP算法：不要求掌握。j=next[j]   next[j] 记录部分匹配的位置，即主子串匹配失败时滑动的位置

  j为主串检查指针 m为主串检查开始位置的针织，i为子串指针   

next[j] 的值为  子串0至i-1的子串在主串中第一次出现的位置，

如果没有则找   子串0至i-2的子串在主串中第一次出现的位置， 直至i=0，i=0时  next[j] =m+1



### 数组与矩阵

数组 a [ 11]   [22]  

存储地址计算 

一维数组  a+i*len   a为起始地址  i 为下表 如果i=8 则前面由0-7（注意从0开始还是从1开始）一共8个 可记8-0  len为单个数据的长度

二维数组： 二维数组 a【m】【n】中  a【i】【j】的地址计算

按行算 a+（i*n+j ）  * len

按列算 a+（j*m+i）  *len 



矩阵：

稀疏矩阵分为 上下三角矩阵   i<=k  和k>=i 配合 上下三角形 可判断除三角形的朝向

上三角矩阵 

111	

110

100   



111

011

001

转换为一维数组（只存1的数据） 求下标 （2n-i+1）*i/2+j     



下三角矩阵 

001	

011

111	

转换为一维数组（只存1的数据） 求下标 （i+1）*i/2+j



对角矩阵 直接画个图自己数

100

010

001



例题   n阶三对角矩阵中 B【k】 （1<=k<=3*n-2） 求k与i、j的关系 如下图

11

111

0111

00111

直接开数  一般数两三个即可

a11  i=1 j=1  k=1

a12  i=1 j=2  k=2

a21 i=2 j=1  k=3

把i、j、k带入选项的公式中算即可









