### 11.1 线性结构

线性结构为逻辑结构

顺序表：可以看作一个数组

读操作：O（1） 

查询操作：依次查找，最少查1次 最多n次 平均  （n+1）/2

插入：O（n）插入一个，后面所有的元素后移  （n+1）/2

删除：O（n） 删除一个，后面所有元素前移  平均：（n-1）/2     最少0 最多n-1

内存连续分配，静态分配，使用之前申请



链表

内存不连续，前一个元素存储下一个元素的地址

首节点：第一个有效数据的节点

尾节点：最后一个有效数据的节点

头节点，首节点前的节点，放链表首地址   头节点的元素位置可放链表长度

头指针：指向头节点的指针变量

尾指针：指向尾节点的指针变量



头指针-头节点-首节点-尾节点-尾指针

1. n个节点离散分布，批次通过指针联系
2. 除头节点和尾节点外，每个节点都有一个唯一的前驱、后继节点
3. 头节点不存放有效数据，只存放链表首地址
4. 加头节点为了方便操作，比如在头部进行删除、插入



链表类型

1. 单链表
2. 循环链表
3. 双向链表

删除、插入时间复杂度 O（1）不需要移动元素，只需要修改指针即可    读操作O（n）



空间性能：

​	空间性能 顺序 事先确定；链式 动态改变     

​	存储密度 顺序=1 更优  链式<1





队列与栈

队列：先进先出，一般用循环单列表表示，入队、出队不需要遍历（由头指针和尾指针完成），入队和出队顺序一致

循环队列

队空：头指针=尾指针

队满：（尾指针+1）%总长度=头指针

队列长度：（头-尾+总长度）%总长度



栈：先近后出





串：可以是数组也可以是链表    代表：字符串

空串！=空格串

存在字符串  abcdef

字串： abc  连续得一部分

子序列： acf  可以非连续得一部分  空串也能算作 字串、子序列  

长度为n的字符串，子序列的个数为  2的n次方

例如 abc  可以转换为二进制 0为未出现 1为出现 则

空串为 000

a为 100

ab为110  以此类推共由 2的3次方个组合   



互异非平凡子串（非空且不等于本身） （n+2）（n-1）/2   找个字符串数数更快

字符串比较ascii码  串相等 长度、字符都相等



模式匹配

朴素算法：主串字符依次与子串匹配，i=j则 i+1，j+1  否则i+1   i为主。最简单的匹配算法

KMP算法：不要求掌握。j=next[j]   next[j] 记录部分匹配的位置，即主子串匹配失败时滑动的位置

  j为主串检查指针 m为主串检查开始位置的针织，i为子串指针   

next[j] 的值为  子串0至i-1的子串在主串中第一次出现的位置，

如果没有则找   子串0至i-2的子串在主串中第一次出现的位置， 直至i=0，i=0时  next[j] =m+1



### 数组与矩阵

数组 a [ 11]   [22]  

存储地址计算 

一维数组  a+i*len   a为起始地址  i 为下表 如果i=8 则前面由0-7（注意从0开始还是从1开始）一共8个 可记8-0  len为单个数据的长度

二维数组： 二维数组 a【m】【n】中  a【i】【j】的地址计算

按行算 a+（i*n+j ）  * len

按列算 a+（j*m+i）  *len 



矩阵：

稀疏矩阵分为 上下三角矩阵   i<=k  和k>=i 配合 上下三角形 可判断除三角形的朝向

上三角矩阵 

111	

110

100   



111

011

001

转换为一维数组（只存1的数据） 求下标 （2n-i+1）*i/2+j     



下三角矩阵 

001	

011

111	

转换为一维数组（只存1的数据） 求下标 （i+1）*i/2+j



对角矩阵 直接画个图自己数

100

010

001



例题   n阶三对角矩阵中 B【k】 （1<=k<=3*n-2） 求k与i、j的关系 如下图

11

111

0111

00111

直接开数  一般数两三个即可

a11  i=1 j=1  k=1

a12  i=1 j=2  k=2

a21 i=2 j=1  k=3

把i、j、k带入选项的公式中算即可



### 树

特性
度：分支的个数，二叉树为2 三叉树为3
内部节点：除了根和叶子节点之外中间的部分
分支节点：下面有分叉的节点
层次/高度/深度：层数



树转二叉树
根节点不变
第一个孩子节点为根节点的左节点。根节点的右节点放根节点的兄弟节点
第二个孩子节点，在第一个孩子节点的右节点
参照 孩子节点在左，兄弟节点在右



满二叉树：除了叶子节点外所有节点的度都为2
完全二叉树：只缺少最后一层右边的节点 比如最后一层有 1234， 123=完全 12=完全 1=完全 124非完全 
a-0 0-1 0-2 0无兄弟的节点 则非完全 
判断是否完全：可以画一个满二叉树，从上往下，从左往右 1234567进行编号，让然后把缺失的节点去掉，编号依然保持12345的连续则完全，出现12346的非连续则不完全



特性：
在第i层上有2^i-1个节点
深度为k最多有（2^k）-1个节点，最少有k个节点，每层一个
节点序号为n，则父节点序号为n/2 向下取整
叶子节点数为A，度为2的节点数为B 则A=B+1



数组与二叉树对应
画一颗深度一样对的满二叉树，将判断二叉树带入满二叉树看，判断二叉树的节点在满二叉树节点的编号即为下标
例如 满二叉树 a-b a-c 转换二叉树 a-c 只有右节点 a=1 b=2 c=3
则数组：
1 2 3 
a ^ c 
没有的记作空或者 ^
不会做就用满二叉树去数

例题 链式存储（数据，左指针，右指针），假如有k个节点，则必定有m=k+1个空指针
k=1 m=2
k=2 m=3
k=3 m=4



二叉树的遍历

前序

中序

后序

层次

掌握遍历的顺序和 根据两种遍历结果还原树





二叉排序树

左孩子小于根节点，右孩子大于根节点

插入节点：判断是否已存在，已存在则不插入。若为空树则新的节点为根。将摇插入的节点与根节点相比较，判断放在左节点还是右节点

删除节点：叶子节点直接删，非叶子节点需要进行调整（不考），调整：找出左边子树最大的节点赋值给删除节点，然后删除左边字数最大节点



最优二叉树（哈夫曼树）：树的代价最小

掌握构建树和求编码

路径长度：叶子节点到根节点的长度

带权路径长度：节点权值*节点路径长度

树的带权路径长度（树的代价）：所有叶子节点带权路径长度之和

构造最优二叉树

例如：5，29，7，8，14，23，3，11

每次找最小的两个节点构造一个新的节点

用3，5构造8节点，并将数组中3，5删除，变为 8，29，7，8，14，23，11

用7，8构造15节点，并将数组中7，8删除，变为 15，29，8，14，23，11

用11，8构造19节点，并将数组中11，8删除，变为 15，29，19，14，23

用14，15构造29节点，并将数组中14，15删除，变为 29，29，19，23

用19，23构造42节点，并将数组中19，23删除，变为 29，29，42

用29，29构造58节点，并将数组中29，29删除，变为 58，42

用58，42构造100节点，并将数组中58，42删除，变为 100

将组合关系画出即可

​                                   100

​                     58                           42

​                29           29          23           19

​         15       14                                   11  8  

​    8     7

3  5

左子树的组合数尽量放左边，右子树的组合数尽量放右边，左侧尽量比右侧大（方便看不是必须）

树的左侧 标记为1 右侧标记为0

5，29，7，8，14，23，3，11分别对应

a，b，c，d，e，f，g，h

5-a，那么在此最优二叉树中可获取编码 11110

29-b为 10

根据组合数放在左右位置的不同，获取的编码可能会不一样，根据选项判断即可



最优二叉树求压缩比：

a     b   c   d   e

40 10 20 16 14  此数字为权重比例

构建最优二叉树

​                                           100

​                          60                                40

​                36                    24 

​      20             16        14    10

求得编码

a=0

b=100

c=111

d=110

e=101

以上为变长编码，因为长短不一

假如用定长编码需要3位二进制 例如 a=000 b=001 c=010 d=011 e=100

压缩比=（3-（40% * 1+ 10 *  3+ 20*  3+ 16* 3+14 * 3））/3=27%

压缩比=（定长长度-树的代价）/定长长度

一般出题权重之和为100，如果不为100则要算出权重比例（节点权重/所有节点权重之和）





平衡二叉树

好久不考

任意节点的左右子树深度相差不超过一

没节点的平衡度只能为-1、0、1



线索二叉树

节点存储下一个要遍历节点的地址

前序线索二叉树：前序遍历的情况下，当某个节点的左节点为空时，则指向前一个遍历元素；右节点为空时指向后一个遍历元素，假如没有后一个遍历元素则为空

​              a 

​      b               c

 d

前序遍历为 abdc      d的左节点指向b，因为前序遍历b为d的前一个；d的右节点指向c，因为前序遍历c为d的后一个

中序后序一样



### 图

存储

完全图

无向图中：没对顶点之间都有一条边连接

有向图中：没对顶点之间都有两条有向边相互连接



连通图

连通图：值任意两个顶点之间都有一个路径相连

例子：1-2-3   1和3之间没有边，但是可以通过2到达3 即为连通图



邻接矩阵存储

一个有n个顶点的图用一个 n阶的矩阵R（二维数组）来表示，其中 Rij =1则表示i顶点与j顶点之间有边。如果边上有权值可将1改为权值。0表示没有边

无向图：

例如 1-2-3 则有矩阵R

010  			

101

010

1节点与2节点有边 所以 R12为1表示 1-2；所以 R21为1表示 2-1

无向图的顶点在矩阵中的关系成对出现（R12和R21）所以必定沿对角线对称

有向图：

例如 1->2->3 则有矩阵R

010  			

001

000

1节点指向2节点有边 所以 R12为1表示 1->2；所以 R21为0因为没有2->1

有向图不一定对称，完全图对称，非完全图不对称



邻接表（链表存储）

用一个链表表示一个顶点，链表的头指针表示该顶点，一个节点表示一个关系



例如 有向  a<-b->c

b（头指针）- a，权重 - c，权重  

a和c在链表中不必纠结谁先谁后



无向图 a-b-c 则构成以下连接表

a - b,权重

b - a,权重 - c,权重

c - b,权重



备注：一般无向图用矩阵，有向图用链表

矩阵 共有n*n的格子，有向图中有e个各自为1，e为边数，无向图为2e

链表 共有n个头指针，有向图中有e个节点，无向图中有2e个节点













