# 3、数据库系统

### 3.1 数据库的基本概念

体系结构：

集中式数据库，单机系统

CS结构，客户端+数据库类似于sqlserver和ssms

分布式数据库：内容分散，物理分布、逻辑分布，存在不同的电脑上，保持除数据外的逻辑独立性和物理独立性。节点独立管理（自治），设有集中控制机制协调各节点。适当增加冗余，提高可靠性、可用性，提高性能。全局一致性，可串行可并行

并行数据库 共享/无共享内容



分布式数据库透明性

分片透明（逻辑上）：不需要关心表如何分片、分块

复制透明 ：不需要关心数据在各个节点之间的复制情况

位置透明（物理上）：不需要关心数据在何处（物理位置），在哪个节点都一样 

局部映像透明性（逻辑透明）：最低层次透明。不需要了解局部的逻辑结构、数据模型，比如使用什么操纵语言，系统自动转换



三级模式结构 （频繁）

内模式（数据库文件、物理级）（内模式、存储模式）

概念模式-内模式映射关系：物理独立性。当物理文件改变时，应用结构不需要改变只需要改变映射关系。参照数据库文件改变路径，需要在数据库管理器中重新指定路径

概念模式（表级）（概念模式、模式）

外模式-概念式映射：保持逻辑独立性，表修改了只需要修改视图的生成逻辑，视图不用修改（参照数据库中的视图）

外模式(视图级)（外模式、用户模式）





数据仓库（与数据挖掘中的概念一致，对老数据归档提供给数据挖掘分析使用）

考的不多 

面向主题：按主题组织，比如按产品分类

集成：消除了数据的不一致性，提供整个企业一致的全局信息

相对稳定性（非易失）：一般指进行查询分析，少有修改和删除（几乎不删除）

反应历史变化（随时间变化）：分析各个时间的数据，对未来有分析和预测



OLAP 联机分析，比如数据仓库，主要用作分析

OLTP 联机事务，比如常用数据库，主要操作增删改查等操作



### 3.2 数据库的设计过程

1分左右

需求分析：当前需求、未来需求、处理需求。产物：数据流图（数据来龙去脉）、数据字典（数据项说明）、需求说明书

概念结构设计：E-R图

逻辑结构设计：数据模型-关系模式。 概念转逻辑时有转换规则和规范化理论

物理设计：考略聚簇索引（比如主键）、 硬件、存放位置等





### 3.3 概念设计阶段

概念设计过程，需求分析后抽象成E-R图

1. 抽象数据
2. 设计局部ER模型
3. 合并局部模型并消除冲突
   1. 多个局部一次性合成
   2. 逐步集成，使用累加的方式一次集成两个
4. 消除冲突（重点。针对同一个对象，不同对象不算冲突）
   1. 属性冲突：是属性域冲突（取值范围）、属性取值冲突（只能取某几个数）
   2. 命名冲突：同名异义、异名同义
   3. 结构冲突：抽象的层次不一致。比如员工抽象成实体和抽象成一个字段、抽象出来的字段数量不一致、字段的排列顺序不一致等
5. 重构优化，消除冗余



E-R图

e：实体,矩形表示。现实世界中区别其他对象的事件/事物

属性，椭圆表示。实体某方面的特性

r：关系,菱形表示。实体之间的联系



属性：

1. 简单属性 原子性不可再分
2. 复合属性 可以继续非分割
3. 单值属性 只对应一个值
4. 多值属性 对应多个，比如一个人有俩手机号，手机号字段同时记录俩
5. null属性
6. 派生属性 由其他属性得来，通过身份证号得出生日



联系：

1.  1-1
2.  1-n
3.  n-n
4. 三元联系，三个对象之间的关系。比如 病房、病人、医生。
   1. 以病人为中心：一个病房对应多个病人，此时病房与病人为1-n。一个医生给多个病人看诊，此时医生为与病人1-n。所以病人端为n
   2. 以病房为中心：一个病人住一个病房，此时病人与病房为1-1。一个医生负责一个病房，此时病房与医生为1-1。所以病房段为1
   3. 以医生为中心：一个病人对应多个医生，此时病人与医生为1-m。一个病房对应一个医生，此时病房与医生为1-1，医生段为m
   4. 总结，以什么为中心，设另外两个对象为1，向中心找关系。以病人为中心，则找一个病房对病人的关系；一个医生对病人的关系。两个关系取后半部分（1-n中的n），后半部分都为1则为1，否则为n
5. 同一实体级内部的二元联系  球队（矩形）-比赛（菱形）：-可分成两根，分为主队和客队，由球队本身决定所以叫内部的二元联系



扩充er模型

弱实体：跟随某个实体，比如学校中家长跟随学生实体；公司中 家属跟随职工。家属用嵌套的矩形表示，联系也用两个嵌套的菱形表示

特殊化：员工特殊化经理。连线中间画实心圆，经理矩形两边有平行线

聚集关系：一边为实体，另一边为联系的整体。一边为经理，另一边为 房屋-租赁-租客，两边关系为签约。联系整体用大矩形圈起来





### 3.4 逻辑结构设计

关系模式概念

数据模型

1. 层次模型
2. 网状模型
3. 关系模型（重点）
4. 面向对象模型



数据模型三要素：数据结构、数据操作、数据的约束条件



关系模型（A={a,b,c,d}）概念

目或度：属性的个数

候选码：唯一标识元祖，且无冗余，可以有一个或多个，可以是单个属性也可以是多个属性集合。可做主键的属性

主键：候选键中任选一个

主属性与非主属性：组成候选码的属性为主属性

外键：其他关系的主键

全码：所有属性组成的候选码。所有列加起来组成主键



关系的类型

1. 基本关系表
2. 查询表
3. 视图表



实体的完整性约束

实体完整性约束：主键唯一，非空

参照完整性约束：外键列值为其他表的主键或为空

自定义完整性：自定义，比如男女用文字或定义成01

触发器（不考）：完整复杂的完整性约束



E-R转关系模式

考的多

一个实体为一张表

ER图转实体表设计

1. 1-1关系转换
   1. 独立关系模式：单独建一张关系表，由双方主键组成，该表主键任意一方主键即可
   2. 归并：将一端的表主键+关系中的属性归并到另外一端，主键保持不变
2.  1-n
   1. 独立关系模式：单独建一张关系表，由双方主键组成，该表主键为n端主键
   2. 归并：将为1的端 主键+关系中的属性归并到为n的端，主键保持不变
3.  n-m
   1. 独立关系模式：单独建一张关系表，由双方主键组成，该表主键双方主键组成



例子：一个校长任职一个学校

独立：

校长：姓名、性别...

学校：校名、地址、电话...

任职（关系）:任职时间、姓名、校名



归并：

校长：姓名、性别、任职时间、校名...

学校：校名、地址、电话...



一个客户有多个账户

独立：

客户：身份证号、姓名、地址...

账户：账户号、余额...

存款人（关系）开户时间、身份证号、账户号



归并：

客户：身份证号、姓名、地址...

账户：账户号、余额、开户时间、身份证号...





### 3.5 代数关系

2-4分 重点



属性列（目、度）必须相同，元组（行，一个实例）。

并（U）：取两个表中的所有数据并去重

交（U向下）：取两个表中的公共部分

差（-）：a-b的差集，为a集合减去a与b的交际部分分。

笛卡尔积（乘号 a*b）：可结构相同或不同。列为两个表列的集合，行为两个表行数相乘。参照sql链接两个表不写条件。select * from a,b   a的第一行链接b的所有行，a的第二行链接b的所有行，依次计算直至链接完成

投影（π表示，π a,b,c 取abc列）：参照单表select a，b

选择（类似于6的符号 61=4，第一个表的第一列=第二个表的第四列）：参照加where 。select a，b form a where a=001  选择a为001的数据。and 对应上尖角（v反过来） or对应下尖角（v）

自然连接（两个对方向的三角）：将所有不重复的列取出，将两表主键进行链接。select guid ,name,age from a inner join b on a.guid=b.guid 注意guid取一次，使用inner join连接





一般考笛卡尔积和自然连接，对比时考虑性能，使两个表列数、行数尽可能小



### 3.6 规范化理论 范式

必考 2-4分

逻辑结构设计时的部分

基本概念



函数依赖：x->y,x依赖y，x决定因素，y被决定因素。学号->姓名 例如： f={学号->姓名}

部分函数依赖，某个被决定因素，只需要部分候选键即可决定，比如 ab->c,a->c 候选键为ab，但是只用a也可决定c，所以部分依赖

传递函数依赖：a->b,b->c，推导出a->c,也可叫做冗余函数依赖，题中的冗余一般指传递函数依赖。a1->a2,a2->a4,a1a2->a3,其中a2->a4是冗余的，a1a2->a3不是

1. 自反律:y为x的一部分所以x->y,较大的部分决定较小的部分
2. 增广率：如果x->y则ax->ay,两侧同时增加则关系不变
3. 传递率：参照传递函数依赖
4. 伪传递规则 x->y,wy->z,xw->z。根据增广率+传递率 wx->wy->z
5. 合并规则：x->y,x->z，所以x->yz
6. 分解规则：x->y,z属于y的一部分则x->z。与合并相反 x->yz,x->y,x->z



候选键：唯一标识元组，没有冗余。任选一个为主键

图示法求候选，入度为0（无箭头指向该属性，a->b a入度为0，b入度为1）的属性一定是候选键的一部分。若入度为0的属性无法遍历整个图，则添加中间节点（既有入度又有出度），直至能遍历所有图的属性集合为候选键

a1->a2,a3->a2,a2->a3,a2->a4。候选键为a1，其他属于冗余

abd->e,ab->g,b->f,c->j,cj->i,g->h。候选键为abcd，其他属于冗余



ab->c,c->b 候选键有 ab（ab推导c，遍历结束）和ac（c推导b，ab推导c，遍历结束）。3个主属性a,b,c



范式判断

第三范式以下会包括：数据冗余、修改异常、插入异常、删除异常问题

1. 第一范式：每个属性都是不可再分的数据项
2. 第二范式：满足一范式后，不存在非主属性部分依赖于候选键。比如候选键ab，其中非主属性c依赖于b（b->c） 则不满足第二范式，因为c对候选键ab部分依赖（只依赖于b）
3. 第三范式：满足二范式后，没有非主属性传递依赖于候选键。比如a->b,b->c。c依赖于b，通过传递依赖于a所以不满足第三范式
4. BC范式：每个依赖的决定因素必须包含候选码。此条不用记具体拆分逻辑。比如:t->j,sj->y， 候选键为sj，st，根据定义t不包含st，所以不满足bc范式

注：没有非主属性至少满足第三范式，候选键为单属性至少满足第二范式



表1：{a->b,ac->d,c->f},当前为第一范式，候选键为ac

表1：{a->b}，表2：{ac->d}，表3：{c->f}。拆分后满足第二范式，由于本来就没有传递依赖，满足第三范式，每个表关系的左边都为候选键所以满足bc范式。范式的升级就是一个拆表的过程







